# RabbitMQ实战指南



## 第一章 RabbitMQ简介

### 重点

1、消息队列中间件，也可以称为消息队列或者消息中间件。它一般有两种传递模式:点对点

(P2P, Point-to-Point) 模式和发布/订阅 (Pub/Sub) 模式。

2、消息中间件的作用：

解耦、冗余〈存储) 、扩展性、削峰、可恢复性、顺序保证、缓冲、异步通信。

3、RabbitMQ 是采用 Erlang 语言实现，最初起源于金融系统，用于在分布式系统中存储转发消息。

4、简单工作流程

生产者：

生产者客户端首先和 RabbitMQ 服务器建立一个连接 (Connection)， 然后在这个连接之上创建一个信道 (Channel)。之后创建一个交换器 （Exchange)和一个队列 （Queue)，并通过路由键进行绑定(在 2.l节中会有关于交换器、队列及路由键的详细解释)。然后发送一 条消息 ， 最后关闭资源。



消费者：

使用QueueingConsurner 会有一些隐患，继承 DefaultConsurner 的方式来实 现 消费。



## 第二章 RabbitMQ入门

### 重点

1、生产者与消费者

生产者创建消息，然后发布到 RabbitMQ 中。消息一般可以包含 2 个部分:消息体和标签CLabel)。

消息体也可以称之为 payload，在实际应用中，消 息体一般是一个带有业务逻辑结构 的数据，比如一个 JSON 字符串。当然可以进一步对这个消息体进行序列化操作。

消息的标签用来表述这条消息 ， 比如 一个交换器的名称和 一个路由键 。 生产者把消息交由 RabbitMQ，RabbitMQ 之后会根据标签把消息发送给感兴趣 的消费者 CConsumer)。



消费者 ,  就是接收消息的 一方。

消费者连接到 RabbitMQ 服务器，并订阅到队列上 。 当消费者消费 一 条消息时 ， 只是消费 消息的消息体 (payload)。 在消息路由的过程中 ， 消息的标签会丢弃 ， 存入到队列中的消息只 有消息体，消费者也只会消费到消息体 ， 也就不知道消息的生产者是谁，当然消费者也不 需要 知道。



Broker: 消息中间件的服务节点 。

对于 RabbitMQ来说， 一个 RabbitMQBroker可以简单地看作一个 RabbitMQ服务节点，或者 RabbitMQ服务实例。 大多数情况下也可以将一个 RabbitMQ Broker看作一台 RabbitMQ服务器 。



首先生产者将业务方数据进行可能的包装 ， 之后封装成消息 ， 发送 CAMQP 协议里这个动作对应的命令为 Basic . Publish) 到 Broker 中 。 消费者订阅并接收消息 CAMQP 协议里这个动作对应的命令为 Basic.Co口surne或者 Basic.Get)，经过可能的解包处理得到原始的数据， 之后再进行业务处理逻辑。

2、简单对比kafka

RabbitMQ 中消息都只能存储在队列中，这 一点 和 Katka 这种消息中间件相反 。 Katka 将消 息存储在 topic (主题)这个逻辑层面，而相对应的队列逻辑只是 topic 实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息井最终投递到队列中，消费者可以从队列中获取消息并消费 。



3、交换器

真实情况是，生产者将消息发送到 Exchange (交换器，通常也 可以用大写的 "X" 来表示)，由交换器将消息路由到一个或者多个队列中。如果路由不到，或 许会返回给生产者，或许直接丢弃。



![绑定建](/Users/xueqiu/gitHub/RabbitMQ绑定建.png)



交换器类型：

fanout: 它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。

direct: direct类型的交换器路由规则也很简单，它会把消息路由到那些 BindingKey和 RoutingKey完全匹配的队列中。

topic:  RoutingKey 和 BindingKey 之间 需要做模糊匹配, BindingKey 中可以存在两种特殊 字符串"*"和"#"，用于做模糊匹配，其中"**"用于匹配一个单词，"#"用于匹配多个单词

headers: 不实用，基本上不会看到它的存在。

4、RoutingKey: 路由键 

生产者将消息发给交换器 的时候， 一般会 指定 一个 RoutingKey，RoutingKey来决定消息流向哪里，用来指定这个消息的路由规则，而这个 RoutingKey 需要与交换器类型和绑定键 (BindingKey) 联 合使用才能最终生效。

5、Binding: 绑定 

 RabbitMQ 中通过绑定将交换器与队列关联起来，在绑定的时候 一般会指定一个绑定键(BindingKey)，这样 RabbitMQ就知道如何正确地将消息路由到队列了。

![RabbitMQ绑定](/Users/xueqiu/gitHub/RabbitMQ绑定.png)



6、生产者和消费者工作流程

生产者：

(1)生产者连接到 RabbitMQBroker， 建立一个连接(Connection)，开启一个信道 (Channel)
(2) 生产者声明一个交换器 ，并设置相关属性，比如 交换机类型、是否持久化等
(3)生产者声明 一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等

(4) 生产者通过路由键将交换器和队列绑定起来。

(5) 生产者发送消息至 RabbitMQ Broker，其中包含路由键、交换器等信息。

(6)  相应的交换器根据接收到的路由键查找相匹配的队列 。

(7)  如果找到 ，则将从 生产者发送过来的消息存入相应的队列中。

(8)  如果没有找到 ，则根据生产者配置的属性选择丢弃还是回退给生产者

(9) 关闭信道。

(10) 关闭连接。

消费者：

(1)消费者连接到 RabbitMQBroker，建立一个连接(Connection)，开启一个信道(Channel)。

(2)消费者向 RabbitMQBroker请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作

(3)等待 RabbitMQ Broker 回应并投递相应队列中的消息，

(4) 消费者确认 (ack) 接收到的消息 。
(5) RabbitMQ 从队列中删除相应己经被确认的消息 。
(6) 关闭信道。

(7) 关闭连接。

